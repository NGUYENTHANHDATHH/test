CAU1:
The multiplicity between Person and Beverage indicates how many beverages a person can have and how many people can have the same beverage.
For example, if the multiplicity is Person * — * Beverage, it means a person can drink many beverages, and a beverage can be consumed by many persons.
CAU2:
The relationship between Beverage, Tea, and Coffee is an inheritance (generalization) relationship.
Beverage is the superclass, and Tea and Coffee are subclasses.
This means Tea and Coffee inherit the common attributes and methods of Beverage,
while they can also have their own specific features.
cAU3:
Algorithm deleteNode(x)
# x is the seat number (or pointer) of the student who leaves

1. if x is NULL then
       print("No such student.")
       return

2. leftNode ← x.llink
3. rightNode ← x.rlink

4. leftNode.rlink ← rightNode
5. rightNode.llink ← leftNode

6. returnNode(x)   # discard the handbook of student x

7. print("Student", x.data, "has left. Circle updated.")
End Algorithm
CAU4:
Algorithm insertNode(position, name)
# position : seat number of the student to the LEFT of the new student
# name     : name (data) of the new student

1. newNode ← getNode()           # give handbook to new student
2. newNode.data ← name

3. leftNode ← position
4. rightNode ← leftNode.rlink    # student currently on the right of position

5. newNode.llink ← leftNode
6. newNode.rlink ← rightNode

7. leftNode.rlink ← newNode
8. rightNode.llink ← newNode

9. print("Inserted new student", name, "between", leftNode.data, "and", rightNode.data)
End Algorithm
CAU5:
he Mandatory Access Control (MAC) model should be used by organizations researching high-tech space technologies.
In MAC, access permissions are centrally controlled and based on security classifications assigned to both users and data.
Users cannot modify access rights on their own, ensuring strict confidentiality, integrity, and protection of highly sensitive information — which is essential for aerospace and defense research environments.
CAU6:
The Discretionary Access Control (DAC) model is suitable for organizations that prioritize work efficiency over security and frequently change their system or authorization structure.
In DAC, data owners control access permissions, allowing quick adjustments to user rights.
It offers high flexibility and ease of management, making it ideal for dynamic organizations, though it provides weaker security compared to MAC.
CAU7:
TCP network server program is being executed where the IP address is 210.183.8.56, and it is waiting at port # 9090, to provide services. Enter the source code required to execute the TCP network server program and Network Socket communication in ⓐ. (10 Points)
import java.io.*;
import java.net.*;

public class TCPServer {
    public static void main(String[] args) {
        ServerSocket serverSocket = null;
        Socket socket = null;
        BufferedWriter writer = null;

        try {
            // ① Create a ServerSocket bound to port 9090
            serverSocket = new ServerSocket(9090, 1, InetAddress.getByName("210.183.8.56"));
            System.out.println("Server is waiting for client connection...");

            // ② Wait for a client to connect
            socket = serverSocket.accept();
            System.out.println("Client connected: " + socket.getInetAddress());

            // ③ Create an output stream to send a message to the client
            writer = new BufferedWriter(
                        new OutputStreamWriter(socket.getOutputStream()));

            // ④ Send a message
            writer.write("Welcome to the TCP Server at 210.183.8.56:9090\n");
            writer.flush();

        } catch (Exception e) {
            e.printStackTrace();

        } finally {
            try {
                if (writer != null) writer.close();
                if (socket != null) socket.close();
                if (serverSocket != null) serverSocket.close();
            } catch (IOException e) {
                // ignore
            }
        }
    }
}
CAU8:
 You may want to execute a Timeout command if the message on the server side is not sent for 60 seconds when reading a message on the TCP network server through the network socket. Enter the source code required to perform this task in ⓑ. (20 Points)
import java.io.*;
import java.net.*;

public class TCPServerTimeout {
    public static void main(String[] args) {
        ServerSocket serverSocket = null;
        Socket socket = null;
        BufferedReader reader = null;

        try {
            // ① Create a ServerSocket on port 9090
            serverSocket = new ServerSocket(9090);
            System.out.println("Server waiting for client connection...");

            // ② Accept client connection
            socket = serverSocket.accept();
            System.out.println("Client connected: " + socket.getInetAddress());

            // ③ Set 60-second read timeout on socket
            socket.setSoTimeout(1000 * 60);

            // ④ Create input stream to read client message
            reader = new BufferedReader(
                        new InputStreamReader(socket.getInputStream()));

            // ⑤ Try to read message
            String message = reader.readLine();
            System.out.println("Received: " + message);

        } catch (SocketTimeoutException e) {
            // ⑥ Handle timeout condition
            System.out.println("Timeout: No message received within 60 seconds.");

        } catch (Exception e) {
            e.printStackTrace();

        } finally {
            try {
                if (reader != null) reader.close();
                if (socket != null) socket.close();
                if (serverSocket != null) serverSocket.close();
            } catch (IOException e) { /* ignore */ }
        }
    }
}
CAU9:
3. Enter the source code required to release used network socket recourses in ⓒ. (20 Points)
finally {
    try {
        if (reader != null) reader.close();     // Close input stream
        if (socket != null) socket.close();     // Close client socket
        if (serverSocket != null) serverSocket.close(); // Close server socket (if server program)
        System.out.println("All network resources have been released.");
    } catch (IOException e) {
        // ignore
    }
}
CAU10:
Communication flows step by step — from top to bottom or bottom to top.

👤 Member’s Viewpoint:

Members communicate only with their immediate superior or subordinate.

Information speed is slow — it must pass through every level.

Risk of distortion increases as messages move through intermediaries.

Decision-making is centralized at the top (A), and lower members (E) have little influence.

Efficient for hierarchical control but poor for creativity or feedback.

A is the central hub connected directly to B, C, D, and E.
Others communicate only through A.

👤 Member’s Viewpoint:

Centralized communication: All messages go through the leader (A).

A receives and distributes all information — very high control and coordination.

Other members (B–E) are dependent on A and have limited interaction with each other.

Efficient for simple or routine tasks where quick decisions are needed.

However, members feel isolated, and A may be overloaded with information.
All members (A, B, C, D, E) are directly connected to one another.

👤 Member’s Viewpoint:

Every member can communicate freely and equally with everyone else.

High participation, satisfaction, and creativity.

Fast feedback and collaborative problem-solving.
CAU11:
The current backup policy of the customer management system has several problems:

Inadequate Backup Frequency: Backups are performed irregularly, risking data loss when recent updates are not captured.

Improper Backup Storage: Backup data is stored on the same server as the live system, making both vulnerable to hardware or disaster failures.

Lack of Verification and Recovery Testing: Backups are not tested for integrity or restorability, so recovery may fail when needed.
These issues make the system unreliable in case of data loss. The company should implement regular automated backups, off-site storage, and periodic recovery testing to ensure data safety and business continuity.

CAU12:
Backup Type	Purpose	Frequency	Storage Duration
Full (Total) Backup	Creates a complete copy of the database for baseline recovery	Once per week (e.g., Sunday 2:00 AM)	Keep 4–6 weeks
Differential Backup	Backs up only data changed since the last full backup	Daily (e.g., Mon–Sat 2:00 AM)	Keep 2–3 weeks
Archive Log Backup	Captures all transaction logs to restore data to any point in time	Every 5–15 minutes	Keep 7–30 days

CAU13:
SELECT 
    R.RoomNo,
    R.RoomChoice,
    SUM(R.RoomRate * Reg.StayDays) AS TotalRate
FROM 
    Room R
JOIN 
    Registration Reg ON R.RoomNo = Reg.RoomNo
WHERE 
    Reg.CheckInDate BETWEEN '2014-07-01' AND '2014-07-31'
GROUP BY 
    R.RoomNo, R.RoomChoice
HAVING 
    SUM(R.RoomRate * Reg.StayDays) > 3000000
ORDER BY 
    TotalRate DESC;
CAU14:
Selected Architecture Pattern: MVC (Model–View–Controller) Pattern

The MVC Pattern is selected for Company L’s next-generation system because it clearly separates user interface (View), business logic (Controller), and data processing (Model).
This separation minimizes unnecessary interactions among layers, improves reusability, and allows functional disassembly and centralized management, all of which align perfectly with the given architecture requirements.

2. Process Flow Explanation
Overall Structure

Model – Manages business data and logic. Communicates with databases through repositories or data access layers.

View – Displays information to the user and sends user inputs to the Controller.

Controller – Acts as the coordinator. It receives user requests, invokes the proper business logic from the Model, and selects a View for the response.

CAU15:
Provide a transaction request interval to apply to the performance test conducted to verify the ‘Functional requirement’ in the [Example] with its estimation equation, then briefly explain the relationship between TPS(Transaction Per Second) and response time. (30 points)

/*
 * Java_Intro_Complete.java
 * Tập hợp ví dụ cho các kiến thức nhập môn Java (cơ bản -> trung cấp sơ khai)
 * - biế́n và kiểu dữ liệu
 * - toán tử
 * - luồng điều khiển
 * - hàm (method)
 * - OOP: lớp, đối tượng, kế thừa, đa hình, interface, trừu tượng
 * - collection: List, Set, Map, iteration
 * - exception
 * - file I/O (text)
 * - thread (Runnable & Thread)
 * - lambda & stream cơ bản
 * 
 * Lưu ý: để chạy từng phần, gọi các phương thức demo tương ứng trong main.
 * Chạy: javac Java_Intro_Complete.java && java Java_Intro_Complete
 */

import java.io.*;
import java.util.*;
import java.util.concurrent.*;
import java.util.function.*;
import java.util.stream.*;

public class Java_Intro_Complete {

    public static void main(String[] args) {
        System.out.println("--- Java Intro Demo ---\n");

        Basics.demo();
        ControlFlow.demo();
        MethodsDemo.demo();
        OOPDemo.demo();
        CollectionsDemo.demo();
        ExceptionsDemo.demo();
        FileIODemo.demo();
        ThreadDemo.demo();
        LambdaStreamDemo.demo();

        System.out.println("\n--- End of Demo ---");
    }
}

// ===================== Basics =====================
class Basics {
    static void demo() {
        System.out.println("[Basics]");

        // primitive types
        int a = 10;
        double b = 3.14;
        boolean flag = true;
        char c = 'A';

        // reference type
        String s = "Hello, Java";

        System.out.printf("int: %d, double: %.2f, boolean: %b, char: %c, String: %s\n",
                a, b, flag, c, s);

        // automatic boxing/unboxing
        Integer boxed = a; // boxing
        int unboxed = boxed; // unboxing

        System.out.println("boxed int + unboxed: " + (boxed + unboxed));

        // Arrays
        int[] arr = {1, 2, 3};
        System.out.println("arr[0] = " + arr[0]);

        // var (local variable type inference, Java 10+)
        var inferred = "inferred String";
        System.out.println("inferred: " + inferred);

        System.out.println();
    }
}

// ===================== Control Flow =====================
class ControlFlow {
    static void demo() {
        System.out.println("[Control Flow]");

        int x = 7;
        if (x % 2 == 0) {
            System.out.println(x + " is even");
        } else {
            System.out.println(x + " is odd");
        }

        // switch
        switch (x) {
            case 1 -> System.out.println("one");
            case 2 -> System.out.println("two");
            default -> System.out.println("other");
        }

        // loop
        for (int i = 0; i < 3; i++) {
            System.out.print(i + " ");
        }
        System.out.println();

        int j = 0;
        while (j < 3) {
            System.out.print(j + " ");
            j++;
        }
        System.out.println();

        // enhanced for
        for (int v : new int[]{10, 20, 30}) {
            System.out.print(v + " ");
        }
        System.out.println("\n");
    }
}

// ===================== Methods =====================
class MethodsDemo {
    static void demo() {
        System.out.println("[Methods]");
        System.out.println("sum(3,4) = " + sum(3, 4));

        // varargs
        System.out.println("avg(2,4,6) = " + avg(2, 4, 6));

        // recursion
        System.out.println("factorial(5) = " + factorial(5));
        System.out.println();
    }

    static int sum(int a, int b) {
        return a + b;
    }

    static double avg(int... nums) {
        return Arrays.stream(nums).average().orElse(Double.NaN);
    }

    static long factorial(int n) {
        if (n <= 1) return 1;
        return n * factorial(n - 1);
    }
}

// ===================== OOP =====================
class OOPDemo {
    static void demo() {
        System.out.println("[OOP]");

        Person p = new Person("An", 25);
        p.sayHello();

        Employee e = new Employee("Binh", 30, "DEV");
        e.sayHello();
        System.out.println("role: " + e.getRole());

        // polymorphism
        Person poly = new Employee("Chi", 28, "QA");
        poly.sayHello(); // uses Employee's override

        // interface
        Animal dog = new Dog("Lucky");
        dog.speak();

        System.out.println();
    }
}

class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public void sayHello() {
        System.out.println("Hello, I'm " + name + ", age " + age);
    }
}

class Employee extends Person {
    private String role;

    public Employee(String name, int age, String role) {
        super(name, age);
        this.role = role;
    }

    @Override
    public void sayHello() {
        System.out.println("Hi, I'm an employee. " + "Role=" + role);
    }

    public String getRole() {
        return role;
    }
}

interface Animal {
    void speak();
}

class Dog implements Animal {
    private String name;

    Dog(String name) { this.name = name; }

    public void speak() { System.out.println(name + " says: Woof!"); }
}

// ===================== Collections =====================
class CollectionsDemo {
    static void demo() {
        System.out.println("[Collections]");

        // List
        List<String> list = new ArrayList<>();
        list.add("one");
        list.add("two");
        list.forEach(System.out::println);

        // Set
        Set<Integer> set = new HashSet<>(Arrays.asList(1, 2, 2, 3));
        System.out.println("set size: " + set.size());

        // Map
        Map<String, Integer> map = new HashMap<>();
        map.put("a", 1);
        map.put("b", 2);
        map.forEach((k, v) -> System.out.println(k + "->" + v));

        // iteration
        for (String s : list) System.out.print(s + " ");
        System.out.println();

        System.out.println();
    }
}

// ===================== Exceptions =====================
class ExceptionsDemo {
    static void demo() {
        System.out.println("[Exceptions]");
        try {
            mayThrow(true);
        } catch (IllegalArgumentException e) {
            System.out.println("caught: " + e.getMessage());
        } finally {
            System.out.println("finally always runs");
        }

        // custom exception
        try {
            checkAge(15);
        } catch (UnderageException e) {
            System.out.println("custom exception: " + e.getMessage());
        }

        System.out.println();
    }

    static void mayThrow(boolean t) {
        if (t) throw new IllegalArgumentException("bad arg");
    }

    static void checkAge(int age) throws UnderageException {
        if (age < 18) throw new UnderageException("Must be 18+");
    }
}

class UnderageException extends Exception {
    public UnderageException(String msg) { super(msg); }
}

// ===================== File I/O =====================
class FileIODemo {
    static void demo() {
        System.out.println("[File I/O]");
        String filename = "sample.txt";

        // write
        try (PrintWriter out = new PrintWriter(new FileWriter(filename))) {
            out.println("Hello file");
            out.println(123);
        } catch (IOException e) {
            System.out.println("write error: " + e.getMessage());
        }

        // read
        try (BufferedReader br = new BufferedReader(new FileReader(filename))) {
            String line;
            while ((line = br.readLine()) != null) {
                System.out.println("read: " + line);
            }
        } catch (IOException e) {
            System.out.println("read error: " + e.getMessage());
        }

        // cleanup (optional)
        new File(filename).delete();

        System.out.println();
    }
}

// ===================== Threads =====================
class ThreadDemo {
    static void demo() {
        System.out.println("[Threads]");

        // Runnable
        Runnable r = () -> {
            try { Thread.sleep(200); } catch (InterruptedException ignored) {}
            System.out.println("Hello from runnable thread");
        };
        Thread t = new Thread(r);
        t.start();

        // ExecutorService
        ExecutorService ex = Executors.newFixedThreadPool(2);
        Future<Integer> f = ex.submit(() -> {
            Thread.sleep(100);
            return 42;
        });
        try {
            System.out.println("future result: " + f.get());
        } catch (Exception e) {
            System.out.println("future error: " + e.getMessage());
        }
        ex.shutdown();

        // join
        try { t.join(); } catch (InterruptedException ignored) {}

        System.out.println();
    }
}

// ===================== Lambda & Stream =====================
class LambdaStreamDemo {
    static void demo() {
        System.out.println("[Lambda & Stream]");

        List<Integer> nums = Arrays.asList(1, 2, 3, 4, 5);

        // lambda: filter even and sum
        int sumEven = nums.stream().filter(n -> n % 2 == 0).mapToInt(Integer::intValue).sum();
        System.out.println("sumEven = " + sumEven);

        // map
        List<String> mapped = nums.stream().map(n -> "n=" + n).collect(Collectors.toList());
        System.out.println(mapped);

        // optional
        Optional<Integer> opt = nums.stream().filter(n -> n > 10).findFirst();
        System.out.println("optional present: " + opt.isPresent());

        System.out.println();
    }
}

#include <iostream>
#include <string>
#include <vector>
#include <map>
#include <set>
#include <algorithm>
#include <fstream>
#include <stdexcept>
using namespace std;

// ====================== 1. STRUCTURE ======================
void demoStructure() {
    cout << "[1. Structure]\n";
    cout << "Hello, C++!" << endl << endl;
}

// ====================== 2. VARIABLES ======================
void demoVariables() {
    cout << "[2. Variables]\n";
    int age = 20; double pi = 3.14; bool ok = true; char ch = 'A';
    string name = "An";
    const double G = 9.8;
    auto inferred = 123.45;
    cout << "age=" << age << ", pi=" << pi << ", name=" << name << endl << endl;
}

// ====================== 3. OPERATORS ======================
void demoOperators() {
    cout << "[3. Operators]\n";
    int a = 5, b = 2;
    cout << "a+b=" << a + b << ", a*b=" << a * b << endl;
    cout << "a==b? " << (a == b) << endl << endl;
}

// ====================== 4. CONTROL FLOW ======================
void demoControl() {
    cout << "[4. Control Flow]\n";
    int x = 3;
    if (x % 2 == 0) cout << "Even"; else cout << "Odd";
    cout << endl;
    switch (x) {
        case 1: cout << "One"; break;
        case 3: cout << "Three"; break;
        default: cout << "Other"; break;
    }
    cout << endl;
    for (int i = 0; i < 3; i++) cout << i << ' ';
    cout << endl << endl;
}

// ====================== 5. FUNCTIONS ======================
int add(int a, int b = 10) { return a + b; }
int factorial(int n) { return n <= 1 ? 1 : n * factorial(n - 1); }
void demoFunctions() {
    cout << "[5. Functions]\n";
    cout << "add(5)=" << add(5) << ", add(5,2)=" << add(5,2) << endl;
    cout << "factorial(5)=" << factorial(5) << endl << endl;
}

// ====================== 6. ARRAYS & POINTERS ======================
void demoArrayPointer() {
    cout << "[6. Arrays & Pointers]\n";
    int arr[3] = {1,2,3};
    int* p = arr;
    for (int i = 0; i < 3; i++) cout << *(p+i) << ' ';
    cout << endl;
    int n = 3;
    int* dyn = new int[n]{4,5,6};
    for (int i = 0; i < n; i++) cout << dyn[i] << ' ';
    delete[] dyn;
    cout << endl << endl;
}

// ====================== 7. STRUCT & ENUM ======================
struct Student { string name; int age; };
enum Color { RED, GREEN, BLUE };
void demoStructEnum() {
    cout << "[7. Struct & Enum]\n";
    Student s = {"Binh", 21};
    Color c = RED;
    cout << s.name << ", age=" << s.age << ", color=" << c << endl << endl;
}

// ====================== 8. OOP ======================
class Person {
protected:
    string name;
public:
    Person(string n): name(n) {}
    virtual void greet() { cout << "Hi, I'm " << name << endl; }
};

class StudentOOP : public Person {
    int id;
public:
    StudentOOP(string n, int i): Person(n), id(i) {}
    void greet() override { cout << "Hello, student " << name << " (ID=" << id << ")\n"; }
};

void demoOOP() {
    cout << "[8. OOP]\n";
    Person p("An"); p.greet();
    StudentOOP s("Binh", 123); s.greet();
    Person* ptr = &s; ptr->greet();
    cout << endl;
}

// ====================== 9. FRIEND & OPERATOR ======================
class Point {
    int x, y;
public:
    Point(int x=0, int y=0): x(x), y(y) {}
    friend Point operator+(const Point&a, const Point&b) {
        return Point(a.x+b.x, a.y+b.y);
    }
    friend ostream& operator<<(ostream& os, const Point&p) {
        return os << '(' << p.x << ',' << p.y << ')';
    }
};

void demoFriendOp() {
    cout << "[9. Friend & Operator]\n";
    Point p1(1,2), p2(3,4);
    cout << p1 + p2 << endl << endl;
}

// ====================== 10. TEMPLATE ======================
template<typename T>
T maxVal(T a, T b) { return a > b ? a : b; }
void demoTemplate() {
    cout << "[10. Template]\n";
    cout << maxVal(3,7) << ", " << maxVal(2.5,1.8) << endl << endl;
}

// ====================== 11. STL ======================
void demoSTL() {
    cout << "[11. STL]\n";
    vector<int> v = {3,1,4};
    sort(v.begin(), v.end());
    for (int x:v) cout << x << ' ';
    cout << endl;

    map<string,int> m = {{"a",1},{"b",2}};
    for (auto [k,vv]:m) cout << k << ' ' << vv << ' ';
    cout << endl;

    set<int> s = {1,2,2,3};
    cout << "set size=" << s.size() << endl << endl;
}

// ====================== 12. EXCEPTION & FILE ======================
void demoExceptionFile() {
    cout << "[12. Exception & File]\n";
    try {
        ofstream out("data.txt");
        out << "Hello file" << endl;
        out.close();

        ifstream in("data.txt");
        if (!in) throw runtime_error("File not found");
        string line; getline(in, line);
        cout << "Read: " << line << endl;
        in.close();
        remove("data.txt");
    } catch (exception &e) {
        cout << e.what() << endl;
    }
    cout << endl;
}

int main() {
    cout << "===== C++ Intro Complete Demo =====\n\n";
    demoStructure();
    demoVariables();
    demoOperators();
    demoControl();
    demoFunctions();
    demoArrayPointer();
    demoStructEnum();
    demoOOP();
    demoFriendOp();
    demoTemplate();
    demoSTL();
    demoExceptionFile();
    cout << "===== End of Demo =====\n";
    return 0;
}

